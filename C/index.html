<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>coco-doc-C: The COCO/NumBBO experiments interface</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="bootstrap.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap.css">
        <script type="text/javascript" src="bootstrap.js"></script>
        <script type="text/javascript" src="customdoxygen.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">coco-doc-C </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The COCO/NumBBO experiments interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/numbbo/coco">COCO (COmparing Continuous Optimisers)</a> is a platform for systematic and sound comparisons of real-parameter global optimizers mainly developed within the <a href="http://numbbo.gforge.inria.fr/doku.php">NumBBO project</a>. COCO provides benchmark function testbeds, experimentation templates which are easy to parallelize, and tools for processing and visualizing data generated by one or several optimizers.</p>
<p>For a getting started guide see <a href="https://github.com/numbbo/coco/blob/master/README.md#getting-started">here</a>.</p>
<p><b>Reimplementation of COCO in ANSI C</b></p>
<p>In order to allow for easier maintenance and further extensions of the COCO platform, it was rewritten entirely from 2014 till 2016. Now, a single implementation in ANSI C (aka C89) is used and called from the other languages to conduct the experiments. This documentation of the COCO C code serves therefore as the basic reference for:</p><ul>
<li><a href="#benchmarking">How to conduct benchmarking experiments in C</a></li>
<li><a href="#new-suites">How to write new test problems and combine them into test suites</a></li>
<li><a href="#new-indicators">How to write additional performance indicators and logging functionality</a></li>
<li><a href="#new-language">How to write an interface to another language</a></li>
</ul>
<p><b>Pointers to the source code and other documentation</b></p>
<p>The actual source code of COCO can be found at <a href="http://github.com/numbbo/coco">http://github.com/numbbo/coco</a></p>
<p>More information about the biobjective test suite (bbob-biobj) can be found at <a href="http://numbbo.github.io/coco-doc/bbob-biobj/functions/">http://numbbo.github.io/coco-doc/bbob-biobj/functions/</a></p>
<p>The experimental procedure is described in <a href="http://numbbo.github.io/coco-doc/experimental-setup/">http://numbbo.github.io/coco-doc/experimental-setup/</a></p>
<h2>How to conduct benchmarking experiments in C <a class="anchor" id="benchmarking"></a></h2>
<p>The best way to create a benchmark experiment is to copy the example experiment and make the required changes to include the chosen optimizer.</p>
<p>In order to simplify the interface between the optimizers and the COCO platform, a static pointer to a COCO problem and a function type for evaluation functions are used: </p><pre class="fragment">static coco_problem_t *PROBLEM;
typedef void (*evaluate_function_t)(const double *x, double *y);
</pre><p>A simplified version of benchmarking a single run of the algorithm <code>my_optimizer</code> on the <code>bbob-biobj</code> suite with default parameters is invoked in the following way (see below for explanation of the <a href="#suite-parameters">suite parameters</a> and <a href="#observer-parameters">observer parameters</a>): </p><pre class="fragment">coco_suite_t *suite;
coco_observer_t *observer;

suite = coco_suite("bbob-biobj", "", "");
observer = coco_observer("bbob-biobj", "");

while ((PROBLEM = coco_suite_get_next_problem(suite, observer)) != NULL) {
  size_t dimension = coco_problem_get_dimension(PROBLEM);

  my_optimizer(evaluate_function, 
               dimension,
               coco_problem_get_number_of_objectives(PROBLEM),
               coco_problem_get_smallest_values_of_interest(PROBLEM),
               coco_problem_get_largest_values_of_interest(PROBLEM),
               dimension * BUDGET_MULTIPLIER,
               random_generator);
}  

coco_observer_free(observer);
coco_suite_free(suite);
</pre><p>The <code>coco_suite_t</code> object is a collection of (in this case biobjective) optimization problems of type <code>coco_problem_t</code>. The while loop iterates through all problems of the suite and optimizes each of them with <code>my_optimizer</code> (a simple random search is used in the <code>example_experiment</code>). The <code>coco_observer_t</code> object takes care of logging the performance of the optimizer. The interface to <code>my_optimizer</code> includes the following parameters:</p><ul>
<li>the function that evaluates solutions on the optimization problem in question,</li>
<li>the number of variables (dimension),</li>
<li>the number of objectives,</li>
<li>the smallest and largest values of interest, which define the region of interest in the decision space,</li>
<li>the maximal budget of evaluations and</li>
<li>the random generator.</li>
</ul>
<p>The optimizer should be run until <code>dimension * BUDGET_MULTIPLIER</code> number of evaluations have been reached. In the <code>example_experiment</code>, the <code>BUDGET_MULTIPLIER</code> is conservatively set using </p><pre class="fragment">static const size_t BUDGET_MULTIPLIER = 2;
</pre><p>so that the experiment runs quickly. The budget needs to be increased for real benchmarking experiments, but this should be done gradually (it might be sensible to test <code>BUDGET_MULTIPLIER = 1e2</code> before any larger values are used) to see how it effects the running time of the benchmark.</p>
<p>The actual <code>example_experiment</code> contains an additional loop that supports <b>independent restarts</b> by <code>my_optimizer</code> and takes care of breaking the loop when the target has been hit or the budget of function evaluations has been exhausted. While the simple random search used in the example does not trigger restarts by itself, a more sophisticated optimizer should (in order to avoid being stuck in a local optimum). When restarting the algorithm the optimizer should not be doing the exactly same thing in every run.</p>
<p>The <code>example_experiment</code> records the time needed for optimizing a problem and can therefore serve also as a <b>timing experiment</b> for an algorithm.</p>
<p>Note that the benchmarking procedure remains the same whether we are dealing with single- or multi-objective problems and algorithms. To perform benchmarking on a different suite and with a different observer, it is enough to replace <code>"bbob-biobj"</code> with the name of the desired suite and observer.</p>
<p>In the above example, the suite and observer are called without additional parameters (the empty strings <code>""</code> are used), which means that their default values apply. These can be changed by calling: </p><pre class="fragment">suite = coco_suite("bbob-biobj", suite_instance, suite_options);
observer = coco_observer("bbob-biobj", observer_options);
</pre><p>where <code>suite_instance</code>, <code>suite_options</code> and <code>observer_options</code> are strings with parameters encoded as pairs <code>"key: value"</code>. When the value consists of one or more integers, it can be encoded using the syntax <code>m-n</code> (meaning all integer values from m to n), <code>-n</code> (meaning all values up to n), <code>n-</code> (meaning all values from n on) and even <code>-</code> (meaning all available values); or by simply listing the values separated by commas (as in <code>2,3,5</code>). No spaces are allowed in the definition of a range or list of values.</p>
<h3>Suite parameters <a class="anchor" id="suite-parameters"></a></h3>
<p>The suite contains a collection of problems constructed by a Cartesian product of the suite's optimization functions, dimensions and instances. The functions and dimensions are defined by the suite name, while the instances are defined with the <code>suite_instance</code> parameter. The suite can be filtered by specifying functions, dimensions and instances through the <code>suite_options</code> parameter.</p>
<p>Possible keys and values for <code>suite_instance</code> are:</p><ul>
<li>either <code>"year: YEAR"</code>, where <code>YEAR</code> is usually the year of the corresponding <a href="http://numbbo.github.io/workshops">BBOB workshop</a> defining the instances used in that year's benchmark,</li>
<li>or <code>"instances: VALUES"</code>, where <code>VALUES</code> is a list or a range <code>m-n</code> of instances to be included in the suite (starting from 1).</li>
</ul>
<p>If both <code>year</code> and <code>instances</code> appear in the <code>suite_instance</code> string, only the first one is taken into account. If no <code>suite_instance</code> is given, it defaults to the year of the current BBOB workshop.</p>
<p>Possible keys and values for <code>suite_options</code> are:</p><ul>
<li><code>dimensions: LIST</code>, where <code>LIST</code> is the list of dimensions to keep in the suite (range-style syntax is not allowed here),</li>
<li><code>dimension_indices: VALUES</code>, where <code>VALUES</code> is a list or a range of dimension indices (starting from 1) to keep in the suite, and</li>
<li><code>function_indices: VALUES</code>, where <code>VALUES</code> is a list or a range of function indices (starting from 1) to keep in the suite, and</li>
<li><code>instance_indices: VALUES</code>, where <code>VALUES</code> is a list or a range of instance indices (starting from 1) to keep in the suite.</li>
</ul>
<p>If both <code>dimensions</code> and <code>dimension_indices</code> appear in the <code>suite_options</code> string, only the first one is taken into account. If no <code>suite_options</code> is given, no filtering by functions, dimensions and instances is performed, i.e. the experiment will be run on the entire benchmark suite.</p>
<p>For example, the call: </p><pre class="fragment">suite = coco_suite("bbob-biobj", 
                   "instances: 10-20", 
                   "dimensions: 2,3,5,10,20 instance_indices:1-5");
</pre><p>first creates the biobjective suite with instances 10 to 20, but then uses only the first five dimensions (skipping dimension 40) and the first five instances (i.e. instances 10 to 14) of the suite.</p>
<p>This kind of filtering can be helpful when parallelizing the benchmark.</p>
<p>See <a href="http://numbbo.github.io/coco-doc/bbob-biobj/functions/">biobjective test suite</a> and <a href="http://coco.lri.fr/downloads/download15.03/bbobdocfunctions.pdf">bbob test sute</a> for more detailed information on the two currently supported suites.</p>
<h3>Observer parameters <a class="anchor" id="observer-parameters"></a></h3>
<p>The observer controls the logging that is performed within the benchmark. Some observer parameters are general, while others are specific to the chosen observer.</p>
<p>Possible keys and values for the general <code>observer_options</code> are:</p><ul>
<li><code>result_folder: NAME</code>, determines the folder within the "exdata" folder into which the results will be output. If the folder with the given name already exists, first NAME_001 will be tried, then NAME_002 and so on. The default value is "default".</li>
<li><code>algorithm_name: NAME</code>, where <code>NAME</code> is a short name of the algorithm that will be used in plots (no spaces are allowed). The default value is "ALG".</li>
<li><code>algorithm_info: STRING</code> stores the description of the algorithm. If it contains spaces, it must be surrounded by double quotes. The default value is "" (no description).</li>
<li><code>number_target_triggers: VALUE</code> defines the number of targets between each 10**i and 10**(i+1) (equally spaced in the logarithmic scale) that trigger logging. The default value is 100.</li>
<li><code>target_precision: VALUE</code> defines the precision used for targets (there are no targets for abs(values) &lt; target_precision). The default value is 1e-8.</li>
<li><code>number_evaluation_triggers: VALUE</code> defines the number of evaluations to be logged between each 10**i and 10**(i+1). The default value is 20.</li>
<li><code>base_evaluation_triggers: VALUES</code> defines the base evaluations used to produce an additional evaluation-based logging. The numbers of evaluations that trigger logging are every base_evaluation * dimension * (10**i). For example, if base_evaluation_triggers = "1,2,5", the logger will be triggered by evaluations dim*1, dim*2, dim*5, 10*dim*1, 10*dim*2, 10*dim*5, 100*dim*1, 100*dim*2, 100*dim*5, ... The default value is "1,2,5".</li>
<li><code>precision_x: VALUE</code> defines the precision used when outputting variables and corresponds to the number of digits to be printed after the decimal point. The default value is 8.</li>
<li><code>precision_f: VALUE</code> defines the precision used when outputting f values and corresponds to the number of digits to be printed after the decimal point. The default value is 15.</li>
</ul>
<p>Possible keys and values for the <code>observer_options</code> of the <code>bbob-biobj</code> observer are:</p><ul>
<li><code>log_nondominated: STRING</code> determines how the nondominated solutions are handled. <code>STRING</code> can take on the values <code>none</code> (don't log nondominated solutions), <code>final</code> (log only the final nondominated solutions), <code>all</code> (log every solution that is nondominated at creation time) and <code>read</code> (the nondominated solutions are not logged, but are passed to the logger as input - this is a functionality needed in pre-processing of the data). The default value is all.</li>
<li><code>log_decision_variables: STRING</code> determines whether the decision variables are to be logged in addition to the objective variables in the output of nondominated solutions. <code>STRING</code> can take on the values <code>none</code> (don't output decision variables), <code>low_dim</code>(output decision variables only for dimensions lower or equal to 5) and <code>all</code> (output all decision variables). The default value is log_dim.</li>
<li><code>compute_indicators: VALUE</code> determines whether to compute and output performance indicators (<code>1</code>) or not (<code>0</code>). The default value is 1.</li>
<li><code>produce_all_data: VALUE</code> determines whether to produce all data required for the workshop. If set to <code>1</code>, it overwrites some other options and is equivalent to setting <code>log_nondominated</code> to <code>all</code>, <code>log_decision_variables</code> to <code>low_dim</code> and <code>compute_indicators</code> to <code>1</code>. If set to <code>0</code>, it does not change the values of the other options. The default value is 0.</li>
</ul>
<p>The benchmark can also be run without any observer, which produces no output, by invoking either <code>""</code> or <code>"no_observer"</code> in place of the observer name.</p>
<h3>Problem evaluation <a class="anchor" id="problem-evaluation"></a></h3>
<p>In order to evaluate the problem, the following method needs to be invoked: </p><pre class="fragment">void coco_evaluate_function(coco_problem_t *problem, const double *x, double *y);
</pre><p>It will evaluate the problem function in point <code>x</code> and save the result in <code>y</code>.</p>
<p>In order to evaluate the constraints of the problem, the following method needs to be invoked: </p><pre class="fragment">void coco_evaluate_function(coco_problem_t *problem, const double *x, double *y);
</pre><p>It will evaluate the problem constraints in point <code>x</code> and save the result in <code>y</code>. Note: while this functionality is provided, the framework does not yet include problems with constraints.</p>
<h3>Problem properties <a class="anchor" id="problem-properties"></a></h3>
<p>Problem properties can be accessed in the following way: </p><pre class="fragment">/* Returns the number of variables i.e. dimension of the problem */
size_t coco_problem_get_dimension(const coco_problem_t *problem);

/* Returns a vector of size 'dimension' with lower bounds of the region of interest in the decision space. */
const double *coco_problem_get_smallest_values_of_interest(const coco_problem_t *problem);

/* Returns a vector of size 'dimension' with upper bounds of the region of interest in  the decision space. */
const double *coco_problem_get_largest_values_of_interest(const coco_problem_t *problem);

/* Returns the number of objectives of the problem */
size_t coco_problem_get_number_of_objectives(const coco_problem_t *problem);

/* Returns the number of evaluations done on the problem */
size_t coco_problem_get_evaluations(coco_problem_t *problem);
</pre><p>See the <code><a class="el" href="coco_8h.html" title="All public COCO functions, constants and variables are defined in this file. ">coco.h</a></code> file for more information on these and other functions that can be used to interface COCO problem and other COCO structures.</p>
<h2>How to write new test problems and combine them into test suites <a class="anchor" id="new-suites"></a></h2>
<p>A test suite is a collection of test problems to be solved during the same benchmarking experiment. Examples of suites in COCO are the single-objective <code>bbob</code> suite with 24 functions, 6 dimensions and 15 instances (i.e., 2160 problem instances in total) and the biobjective <code>bbob-biobj</code> suite with 55 functions, 6 dimensions and 10 instances (i.e., 3300 problem instances in total). Note that although the terms <em>function</em> and <em>problem</em> are sometimes used ambiguously, their meaning should be clear from the context.</p>
<p>Writing a new test suite entails:</p>
<ol type="1">
<li>Implementing a new set of functions (or reusing existing functions),</li>
<li>Defining problem instances, and</li>
<li>Collecting problems into a suite.</li>
</ol>
<h3>Implementing new test functions</h3>
<p>Test functions are implemented in the C files starting with <code>f_</code>. Let us use the sphere function from <code><a class="el" href="f__sphere_8c.html" title="Implementation of the sphere function and problem. ">f_sphere.c</a></code> to illustrate how this is done. Each function is implemented using three methods: </p><pre class="fragment">/* Returns the square of x */
static double f_sphere_raw(const double *x, const size_t dimension);

/* Uses the f_sphere_raw method to compute the function value and store it in y, and the */
/* problem properties to access other data, for example, the dimension */
static void f_sphere_evaluate(coco_problem_t *problem, const double *x, double *y);

/* Creates the sphere problem as a function of the dimension */
static coco_problem_t *f_sphere_allocate(const size_t dimension);
</pre><p>Implementing a new test function called <em>blue</em> would mean defining three new methods <code>f_blue_raw</code>, <code>f_blue_evaluate</code> and <code>f_blue_allocate</code>. The actual function would be defined in <code>f_blue_raw</code>, while the the other two methods would be very similar to <code>f_sphere_evaluate</code> and <code>f_sphere_allocate</code> and would require little effort to implement.</p>
<h3>Defining problem instances</h3>
<p>In order to make the optimization problems more challenging, <b>transformations</b> such as shifts, oscillations, conditioning and others can be <em>wrapped around</em> the basic function or other transformations. For example, the BBOB sphere problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[y = \sum_{i=1}^D (x_i-x_i^{\mathrm{opt}})^2 + f^{\mathrm{opt}},\]" src="form_0.png"/>
</p>
<p> was created from the basic sphere function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[y = \sum_{i=1}^D x_i^2,\]" src="form_1.png"/>
</p>
<p> using two transformations, a shift in the decision space by <img class="formulaInl" alt="$x^{\mathrm{opt}}$" src="form_2.png"/> and a shift of the function value by <img class="formulaInl" alt="$f^{\mathrm{opt}}$" src="form_3.png"/>.</p>
<p>Transformations take a problem (a <code>coco_problem_t</code> object often referred to as the inner problem) with some parameters and return the transformed problem (again a <code>coco_problem_t</code> object). Depending on whether they act on decision variables or the objective value, they are implemented in C files starting with <code>f_transform_vars</code> or <code>f_transform_obj</code>, respectively.</p>
<p>For example, the BBOB sphere problem is implemented as: </p><pre class="fragment">problem = f_sphere_allocate(dimension);
problem = transform_vars_shift(problem, xopt, 0);
problem = transform_obj_shift(problem, fopt);
</pre><p>Note that transformations of the decision variables first perform the transformation and only then evaluate the inner problem using the new transformed variables, while the transformations of the objective variable first evaluate the inner problem and then transform its output. This is why the BBOB Rastrigin problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[y = 10 \left( D - \sum_{i=1}^D \cos{(2 \pi z_i)} \right) + ||z||^2 + f^{\mathrm{opt}}, \quad \mathrm{where} \quad \mathbf{z} = \Delta^{10}T^{0.2}_{\mathrm{asy}}(T_{\mathrm{osz}}(\mathbf{x} - \mathbf{x}^{\mathrm{opt}}))\]" src="form_4.png"/>
</p>
<p> is defined using the following order of transformations: </p><pre class="fragment">problem = f_rastrigin_allocate(dimension);
problem = transform_vars_conditioning(problem, 10.0);
problem = transform_vars_asymmetric(problem, 0.2);
problem = transform_vars_oscillate(problem);
problem = transform_vars_shift(problem, xopt, 0);
problem = transform_obj_shift(problem, fopt);
</pre><p>Varying the values of <img class="formulaInl" alt="$x^{\mathrm{opt}}$" src="form_2.png"/> and <img class="formulaInl" alt="$f^{\mathrm{opt}}$" src="form_3.png"/> yields <b>different instances</b> of the same BBOB problem. Each problem instance is therefore defined by dimension and instance number and implemented in a method such as: </p><pre class="fragment">static coco_problem_t *f_sphere_bbob_problem_allocate(const size_t dimension,
                                                      const size_t instance,
                                                      ...);
</pre><p>The <code>f_blue_problem_allocate</code> method implementing the <em>blue</em> problem would therefore contain a call to <code>f_blue_allocate</code>, possibly some transformations, and finally calls to methods <code>coco_problem_set_id</code>, <code>coco_problem_set_name</code> and <code>coco_problem_set_type</code> to set these problem properties. Note that problem allocation methods need to be deterministic (return the same object given the same argument values).</p>
<h3>Collecting problems into a suite</h3>
<p>Once all the required problems are given, they need to be combined into a suite. A suite called <em>red</em> would have to implement the following methods stored in the <code>suite_red.c</code> file: </p><pre class="fragment">static coco_suite_t *suite_red_initialize(void);
static coco_problem_t *suite_red_get_problem(coco_suite_t *suite,
                                             const size_t function_idx,
                                             const size_t dimension_idx,
                                             const size_t instance_idx);
</pre><p>The initialization is very simple, it requires a call to the suite allocation method, where the number of functions, available dimensions and default instances are set: </p><pre class="fragment">static coco_suite_t *coco_suite_allocate(const char *suite_name,
                                         const size_t number_of_functions,
                                         const size_t number_of_dimensions,
                                         const size_t *dimensions,
                                         const char *default_instances);
</pre><p>The <code>suite_red_get_problem</code> method has to return the right problem given the suite and function, dimension and instance indices.</p>
<p>In case the suites instances depend on the year (as is the case with the <code>bbob</code> and <code>bbob-biobj</code> suites), a method that returns a string of instances for the given year can be defined as: </p><pre class="fragment">static const char *suite_red_get_instances_by_year(const int year);
</pre><p>In order for the newly-implemented suite to be included in COCO, the following methods from <code><a class="el" href="coco__suite_8c.html" title="Definitions of functions regarding COCO suites. ">coco_suite.c</a></code> need to be updated (two lines per suite need to be added to each of these methods): </p><pre class="fragment">static coco_suite_t *coco_suite_intialize(const char *suite_name); 
static coco_problem_t *coco_suite_get_problem_from_indices(coco_suite_t *suite,
                                                           const size_t function_idx,
                                                           const size_t dimension_idx,
                                                           const size_t instance_idx);
static const char *coco_suite_get_instances_by_year(const coco_suite_t *suite, const int year);
</pre><h2>How to write additional performance indicators and logging functionality <a class="anchor" id="new-indicators"></a></h2>
<p>Here we provide guidelines for implementing a new observer/logger and adding a new performance indicator to the <code>bbob-biobj</code> logger.</p>
<h3>Implementing a new observer/logger</h3>
<p>First, let us clarify the difference between observers and loggers. An <b>observer</b> (a <code>coco_observer_t</code> object) is a stand-alone entity that can exist independently from problems and test suites. It is defined only by its name and options (see <a href="#observer-parameters">observer parameters</a>). On the other hand, a <b>logger</b> is a COCO problem (a <code>coco_problem_t</code> object) that is wrapped around the problem to be observed. It exists only for the time span in which its underlying problem exists. The logger needs information from the observer to be able to create log files with some continuity. The observer's task is therefore keeping track of the logging performed on the whole suite, while the actual logging is done by the logger.</p>
<p>When a new logging functionality is required, both a new observer and a new logger need to be defined. Observers are 'derived' from the <code>coco_observer_t</code> object, which already contains various information that can be used by an observer. Creating a <em>yellow</em> observer means implementing the following structure and methods in the <code>observer_yellow.c</code> file: </p><pre class="fragment">/* Structure containing data specific to the yellow observer */
typedef struct {...} observer_yellow_data_t;

/* Method for freeing the data contained in observer_yellow_data_t (if needed) */
static void observer_yellow_free(void *data);

/* Observer constructor that initializes observer_yellow_data_t and connects the observer with the yellow logger */
/* (set the observer's logger_allocate_function and logger_free_function fields) */
static void observer_yellow(coco_observer_t *observer, const char *options, coco_option_keys_t **option_keys);
</pre><p>The yellow logger in the <code>logger_yellow.c</code> file needs to implement the following structure and methods: </p><pre class="fragment">/* Structure containing data specific to the yellow logger */  
/* (typically pointers to data files etc.) */   
typedef struct {...} logger_yellow_data_t;

/* Method for freeing the data contained in logger_yellow_data_t (if needed) */
static void logger_yellow_free(void *data);

/* Method that evaluates the inner problem and performs logging */
static void logger_yellow_evaluate(coco_problem_t *problem, const double *x, double *y);

/* Logger constructor that initializes logger_yellow_data_t */
static coco_problem_t *logger_yellow(coco_observer_t *observer, coco_problem_t *inner_problem);
</pre><p>In order to add the observer to the existing observers in COCO, the method <code>coco_observer(...)</code> in <code><a class="el" href="coco__observer_8c.html" title="Definitions of functions regarding COCO observers. ">coco_observer.c</a></code> needs to be updated (two lines per observer have to be added). Moreover, information on the new observer and its parameters should also be added to this documentation file (see <a href="#observer-parameters">observer parameters</a>).</p>
<h3>Adding a new performance indicator to the <code>bbob-biobj</code> logger</h3>
<p>So far, the <code>bbob-biobj</code> logger contains a single performance indicator - the hypervolume of all nondominated solutions. We now present how other indicators can be added to this logger.</p>
<p>Indicators of the <code>bbob-biobj</code> logger are of type <code><a class="el" href="structlogger__biobj__indicator__t.html" title="The indicator type. ">logger_biobj_indicator_t</a></code> and are stored in the array <code>indicators</code> in the <code><a class="el" href="structlogger__biobj__data__t.html" title="The bi-objective logger data type. ">logger_biobj_data_t</a></code> data structure. Currently, <code>indicators</code> contains a single indicator, but can be easily extended to contain more. For example, to add a <em>green</em> indicator, the global counter <code>LOGGER_BIOBJ_NUMBER_OF_INDICATORS</code> in <code><a class="el" href="logger__biobj_8c.html" title="Implementation of the bbob-biobj logger. ">logger_biobj.c</a></code> needs to be increased, the global variable <code>logger_biobj_indicators</code> needs to be extended with the string <code>"green"</code>, and the array <code>suite_biobj_best_values_green</code> containing best green indicator values for each problem instance in the <code>bbob-biobj</code> test suite needs to be created and invoked within the <code>suite_biobj_get_best_value(...)</code> function in <code><a class="el" href="suite__biobj_8c.html" title="Implementation of two bi-objective suites created by combining two single-objective problems from the...">suite_biobj.c</a></code>.</p>
<p>Computing/updating the indicator value is done within the following two methods: </p><pre class="fragment">/* Updates the AVL tree containing nondominated solutions */
static int logger_biobj_tree_update(logger_biobj_data_t *logger,
                                    logger_biobj_avl_item_t *node_item);

/* Outputs data to the .dat and .tdat files */
static void logger_biobj_output(logger_biobj_data_t *logger,
                                const int update_performed,
                                const logger_biobj_avl_item_t *node_item)
</pre><p>The <code>bbob-biobj</code> logger keeps an archive of all nondominated solutions in the form of an AVL tree. The <code>logger_biobj_tree_update</code> method checks for domination of the given solution (<code>node_item</code>) and updates the archive and the values of the indicators if the given node is not weakly dominated by existing nodes in the archive. Here the green indicator value needs to be updated any time a solution is added to or removed from the archive.</p>
<p>When the archive changes, the overall indicator values are further updated in the <code>logger_biobj_output</code> method just before being output. An update of the overall green indicator value is required at this point.</p>
<p>Other functionalities, such as initializing, freeing and outputting to the indicator-specific files should 'work out of the box' without requiring additional tweaking for individual indicators.</p>
<h2>How to write an interface to another language<a class="anchor" id="new-language"></a></h2>
<p>COCO's experiments module, written in C, can be interfaced to support running benchmarking experiments in other programming languages. Such an interface already exists for <a href="https://github.com/numbbo/coco/tree/master/code-experiments/build/c">C/C++</a>, <a href="https://github.com/numbbo/coco/tree/master/code-experiments/build/python">Python</a>, <a href="https://github.com/numbbo/coco/tree/master/code-experiments/build/java">Java</a> and <a href="https://github.com/numbbo/coco/tree/master/code-experiments/build/matlab">Matlab/Octave</a>. Adding an interface to another language comprises providing:</p>
<ul>
<li>wrappers in that language that expose all methods listed in <code><a href="coco_8h.html">coco.h</a></code>,</li>
<li>an example experiment that showcases the use of these methods, and</li>
<li>a (short) documentation on using the interface containing sections about 'Prerequisites', 'Getting Started', and 'Details and Known Issues'.</li>
</ul>
<p>See the already supported languages for examples of each of these points. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
